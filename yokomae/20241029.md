# やったこと

## actuation_cmd_converter.cpp　の改造

### 曲がりにくさ追加
`msg->actuation.steer_cmd`が、受信した目標操舵角度だが、それを半分にすることで、実車の曲がりにくさをシミュレートした。
すなわち、目標操舵角度の倍を指令しないと必要な角度曲がれないようになる。
```
  double target_angle = msg->actuation.steer_cmd / 2.0; // 曲がり難さを考慮して、目標操舵角を半分にする。steer_v_limit_も半分にする必要あり。
```

### 操舵角速度制限
`subscription SteeringReport`を追加して、現在の操舵角(`steering_report_->steering_tire_angle`)を取得し、
上で求めた目標操舵角度との差分が、実車制限の0.35rad/sを超えないようにリミットをかけた。
なお、このモジュールの処理周期が30msのようなので、上記の角速度を30msあたりの値として求め、
実際の値は、PlotJugglerでグラフを見ながら微調整した。
```
  if (std::fabs(target_angle - current_angle) > steer_v_limit_ ) {
    if (target_angle > current_angle) {
      target_angle = current_angle + steer_v_limit_;
    } else {
      target_angle = current_angle - steer_v_limit_;
    }
  }
```
リミットの、`steer_v_limit_`は、aichallenge_awsim_adapter.launch.xmlで設定できるよう追加した変数。
```
    <param name="steer_v_limit" value="0.0399"/> <!-- 実機の曲がりにくさを考慮すると、制限は半分が妥当 0.35rad/sの半分に相当する値。多少誤差はあるかもしれないが正しそう -->
```

### 操舵角制限
そうして算出した目標操舵角度が、実車のMaxである、32degを超えないようにリミットをかけた。パラメータは使わず、直値で指定している。
```
  // Add steer_cmd to history. Limit -35 deg to 35 deg
//  steer_cmd_history_.emplace_back(msg->header.stamp, std::clamp(msg->actuation.steer_cmd, -0.61, 0.61));
  steer_cmd_history_.emplace_back(msg->header.stamp, std::clamp(target_angle, -0.5585, 0.5585)); // 実際の舵角は、32deg=0.5585rad
```
なお、このモジュールの中で、目標操舵角の出力に0.2secの遅延がかかるように処理（上でemplace_back()で一旦queueに登録）されている。
実際の出力は下記でdequeueされて出力される。
```
  output.lateral.steering_tire_angle = get_delayed_steer_cmd(msg->header.stamp);
```

## simple_pure_pursuit.cpp/hpp の改造 reference.launch.xml へのパラメータ追加

### 自己位置予測
GNSSからの信号が0.5sの遅延があるので、GNSSと合成して算出されているkinematicで得られる位置座標は、
実際の車体の位置より、0.5s古い位置である。
さらに、前述したように操舵出力には0.2sの遅延がある（実車データでも同じ遅延があったので、これを再現している？あるいは、バグ？）。
そのような遅延があると、操舵の指令値とのずれから、操舵を機敏に動かしても、振動が大きくなり、発散する。

安定したフィードバック制御をするには、遅延を極力減らさなければならない。
正確な自車位置や自車の姿勢がわかれば、そこからの安定して制御できる指令値を出すことができる。

そのため、0.2s+0.5s = 0.7s後の自車位置と自車姿勢を求められるようにした。

パラメータ `predict_time` [sec]後の、自車位置(x, y)と、自車の向き(yaw)を、
現在値(x, y)と現在の走行速度から、および、現在の自車の向き(yaw)と現在の自車の角速度(z)から求めた。
```
  double current_longitudinal_vel = odometry_->twist.twist.linear.x; // 現在の速度
  double yaw = tf2::getYaw(odometry_->pose.pose.orientation);// 現在の車体の向き。x軸と一致する向きが0
  double predicted_x = odometry_->pose.pose.position.x + std::cos(yaw) * current_longitudinal_vel * predict_time_;
  double predicted_y = odometry_->pose.pose.position.y + std::sin(yaw) * current_longitudinal_vel * predict_time_;
  double predicted_yaw = yaw + odometry_->twist.twist.angular.z * predict_time_; // zは、車体の角速度（ラジアン/秒）

```
ただ、どうしても、現在の情報からの推測になり、段々変わっていく操舵角などは考慮していないので、
予測時間が大きくなればなるほど、実際の自車位置とのズレは大きくなる。
そのため、reference.launch.xmlにパラメータ`predict_time`を用意して、予測時間を微調整できるようにした。
```
    <param name="predict_time" value="0.4"/> <!-- n秒先の自己位置を予測する -->
```
なお、ルックアヘッドポイントの取得は、予測自己位置から、算出するように変更した。こうしないと遅延したGNSSの位置からのルックアヘッドポイントを取得するのでおかしな動きになる（最初、気づかず、変な動きになっていることにしばらく悩んだ）。
```
  geometry_msgs::msg::Pose predicted_pos = odometry_->pose.pose;
  predicted_pos.position.x = predicted_x;
  predicted_pos.position.y = predicted_y;

//  size_t closet_traj_point_idx =
//    findNearestIndex(trajectory_->points, odometry_->pose.pose.position);
  size_t closet_traj_point_idx = findNearestIndex(trajectory_->points, predicted_pos.position);
```

### GNSS異常検出、および、異常時の速度制限
/sensing/gnss/pose_with_covariance　を受信するsubscriptionを追加して、GNSSの出力値を取得し、
その位置情報(x, y)（以後、GNSS位置）と、input/kinematics から得られた位置情報(x, y)（以後、kinematics位置）との距離の差が、
現在の速度[m/s]で1s間に進む距離(=速度と同じ値)より大きい場合、GNSS信号の異常と判断し、速度制限として、目標速度を5km/hに固定した。
GNSSからの受信値は0.5sの遅延があるということなので、余裕を見て倍の時間とした。
GNSS位置と、kinematics位置の差が、現在の速度以下になったら、速度制限を解除する。

ちなみに、この機能のテストは、上で取得したGNSSの値をテスト用コードで所定時間同じ値を保持するようにして確認した。

### ルックアヘッドポイントの2重化
ルックアヘッド距離が短いと、走行経路への追従は良いが、操舵出力の遅延や操舵角速度制限があるため、操舵が不安定になる。
ルックアヘッド距離が長いと、操舵は安定する一方で、コーナーで、内回りになり、壁に引っかかる。

そこで、長短2つのルックアヘッド距離を指定できるようにして、両者から求めた操舵角の平均を目標操舵角にするようにした。

たとえば、近いルックアヘッドポイントは左にまがっていて、遠いルックアヘッドポイントも更に左に曲がっている場合、
左に大きめに操舵を切るような目標操舵角になる。

一方、近いルックアヘッドポイントが左に曲がったところにあり、遠いルックアヘッドポイントが逆の右に曲がったところにある
場合、両者の操舵角は互いに相殺するような関係になるので、それらから求めた操舵角の平均は、現在の操舵角とあまり動かなくなる。すなわち、ほぼ現在の操舵角のまま進み続け、やがて、遠いルックアヘッドポイントの影響が大きくなって右に操舵を切っていく。

２つのルックアヘッドポイントを使わず1つだった場合、近点が左だから左に操舵を切った直後、今度は右に操舵を切るというような動きになり、曲がりにくさや操舵角速度制限により、右への操舵が間に合わず、壁に直行することになる。

つまり、2つのルックアヘッドポイントにより、曲がりがきつい場合は多めに操舵を切り、S字っぽいカーブの場合には、操舵を極力切らないことで、操舵角度制限や曲がりにくさへの対策としている。

### マップ指定速度の定数倍化
目標速度を複数種類設定したMapを作るのはとても手間がかかるので、パラメータで指定された定数で、マップから読み込んだ目標速度を定数倍加する処理を追加した。
これにより、現場での速度の微調整などが可能になる。

### 操舵角度による速度制限
コーナーを高速で走行すると、操舵が間に合わないので、操舵角が所定角度以上になったら、目標速度に制限をかけるようにした。
ただし、コーナー手前で減速したり、コーナー出口から加速するといったことができないので、速度指示が入ったマップが完成するまでの暫定手段。
パラメータで本機能を無効化できる。

### 操舵微分制御の廃止
操舵の追従性向上のため、操舵制御をPD制御で行うようにしていたが、操舵角速度制限の影響が大きく、
微分制御により、早めに大きく操舵を切ると、その戻しが間に合わなくなり、かえって、走行が不安定に
なってしまうため、廃止した。
ただし、不安定さを十分に検証したわけではないので、うまく調整すれば効果はあるかもしれない。

### 公式ソースコードのバグ修正
後輪のセンター位置を求める式で、yawを使わなければならないところで、ｚ（車体の角速度）が使われていて、
実走行上でも、車体が目標経路の右側を走るという不具合があったので、修正した。


